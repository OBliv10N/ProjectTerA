#include <SFML/Graphics.hpp>
#include<time.h>
using namespace sf;

const int displaywidth = 10;
const int displaydheight = 20;

int display[displaydheight][displaywidth] = {0};  //size of display//

struct point {
    int x, y;
}
b[4] = { {1,0},{1,1},{1,2},{1,3} }, w[4];

point blocks[7][4] = {    //blocks//
 
 { {1,0},{1,1},{1,2},{1,3} },

 { {0,1},{1,1},{1,2},{2,2} },

 { {0,1},{1,1},{2,1},{1,2} },

 { {0,0},{1,0},{1,1},{1,2} },

 { {0,1},{1,1},{0,2},{1,2} },

 { {0,2},{1,1},{1,2},{2,1} },

 { {1,0},{1,1},{1,2},{2,0} }   
              
};

bool check()    //check cash display//
{
    for (int i = 0; i < 4; i++)
        if (b[i].x < 0 || b[i].x >= displaywidth || b[i].y >= displaydheight) return 0;
        else if (display[b[i].y][b[i].x] != 0) return 0;

    return 1;
};

int main() {

    srand(time(0));

    int m = 0, Num = 1;
    bool rotate = false;
    float timer = 0, delay = 0.3;

    RenderWindow window(VideoMode(320, 480), "Play Game!");    //size of windows & name//

    Clock t;

    Texture c;
    /* c.loadFromFile("image/tiles.png"); */

    Sprite s(c);

    while (window.isOpen()) {

        float time = t.getElapsedTime().asSeconds();
        t.restart();
        timer += time;

        Event event;
        while (window.pollEvent(event)) {

            if (event.type == Event::Closed) window.close();

            if (Keyboard::isKeyPressed(Keyboard::Up)) rotate = true;
            else if (Keyboard::isKeyPressed(Keyboard::Left)) m = -1;
            else if (Keyboard::isKeyPressed(Keyboard::Right)) m = 1;
        }
        if (Keyboard::isKeyPressed(Keyboard::Down)) delay = 0.01;   //for go down quick//

            //rotate//

            if (rotate) {
                point p = b[1];
                int x, y;

                for (int i = 0; i < 4; i++) {
                    x = b[i].y - p.y;
                    y = b[i].x - p.x;
                    b[i].x = p.x - x;
                    b[i].y = p.y + y;
                }
            }
            if (!check()) {
                for (int i = 0; i < 4; i++) b[i] = w[i];
            }

            //move//

            for (int i = 0; i < 4; i++) {
                w[i].x = b[i].x;
                b[i].x += m;
            }
            if (!check()) {
                for (int i = 0; i < 4; i++) b[i] = w[i];
            }

            //down//

            if (timer > delay) {
                for (int i = 0; i < 4; i++) {
                    w[i] = b[i];
                    b[i].y += 1;
                }
                if (!check()) {
                    for (int i = 0; i < 4; i++) {
                        display[w[i].y][w[i].x] = Num;
                    }
                    Num = 1 + rand() % 7;

                    int N = rand() % 7;

                    for (int i = 0; i < 4; i++) {
                        b[i].x = blocks[N][i].x;
                        b[i].y = blocks[N][i].y;
                    }
                }
                timer = 0;
            }

            //checkline//

            int k = displaydheight - 1;

            for (int i = displaydheight - 1; i > 0; i--) {
                int count = 0;

                for (int j = 0; j < displaywidth; j++) {
                    if (display[i][j] != 0) count++;
                    display[k][j] = display[i][j];
                }
                if (count < displaywidth) k--;  //delete Array (pointer);
            }

        m = 0; rotate = 0; delay = 0.3;
        window.clear(Color::Black);
        

        for (int i = 0; i < displaydheight; i++) {
            for (int j = 0; j < displaywidth; j++) {
                if (display[i][j] == 0) continue;

                s.setTextureRect(IntRect(display[i][j] * 18, 0, 18, 18));
                s.setPosition(j * 18, i * 18);
                s.move(24, 24);
                window.draw(s);
            }
        }

        m = 0; rotate = false; delay = 0.5;

        for (int i = 0; i < 4; i++) {
            s.setTextureRect(IntRect(Num * 18, 0, 18, 18));
            s.setPosition(b[i].x * 18, b[i].y * 18);
            s.move(24, 24);
            window.draw(s);
        }
        
        window.display();
    }

    return 0;
}
