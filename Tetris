#include <SFML/Graphics.hpp>
#include<time.h>
using namespace sf;

const int nfieldwidth = 12;
const int nfieldheight = 18;

int field[nfieldheight][nfieldwidth] = {};//ขนาดของเกม


struct point {
    int x, y;
}b[4], w[4];

int blocks[7][4] = {      //บล็อกค้าบไอ้ต้าว
    2,6,10,14, /*  .X..
                   .X..
                   .X..
                   .X..    */
    6,7,10,11,/*   ....
                   .XX.
                   .XX.
                   ....   */

    7,10,11,15,  /*....
                   ..X.
                   .XX.
                   ..X.     */
    6,10,11,14,  /*....
                   .X..
                   .XX.
                   .X..     */
    7,10,11,14, /* ....
                   ..X.
                   .XX.
                   .X..    */
   6,10,11,15,  /* ....
                   .X..
                   .XX.
                   ..X.    */

    7,13,14,15 /*  ....
                   ..X.
                   ..X.
                   .XX.     */


};

bool check()       //ชนขอบหรือป่าว
{
    for (int i = 0; i < 4; i++)
        if (b[i].x < 0 || b[i].x >= nfieldwidth || b[i].y >= nfieldheight) return 0;
        else if (field[b[i].y][b[i].x]) return 0;

    return 1;
};

int main()
{
    RenderWindow window(sf::VideoMode(1080, 720), "Play Game!");

    Clock t;

    Texture c;
    c.loadFromFile("Image/tiles.png");

    Sprite s(c);
    s.setTextureRect(IntRect(0, 0, 18, 18));

    int m = 0; bool rotate = 0; double timer = 0; double delay = 0.25; double speed = 1;

    while (window.isOpen()) {

        double time = t.getElapsedTime().asSeconds();
        t.restart();
        timer += time;


        Event event;
        while (window.pollEvent(event))
        {
            if (event.type == Event::Closed) window.close();


            if (Keyboard::isKeyPressed(Keyboard::Up)) rotate = true;
            else if (Keyboard::isKeyPressed(Keyboard::Left)) m = -1;
            else if (Keyboard::isKeyPressed(Keyboard::Right)) m = 1;





            if (rotate) {
                point p = b[1];
                for (int i = 0; i < 4; i++) {
                    int x = b[i].y - p.y;
                    int y = b[i].x - p.x;
                    b[i].x = p.x - x;
                    b[i].y = p.y + y;
                }
            }


            // Move
            for (int i = 0; i < 4; i++) {
                w[i].x = b[i].x;
                b[i].x += m;
            }

            //down
            if (timer > delay) {
                for (int i = 0; i < 4; i++) {
                    b[i].y += 1;
                    timer = 0;

                }
            }


        }

        int n = 2;
        if (b[1].x == 0)
            for (int i = 0; i < 4; i++) {
                b[i].x = blocks[n][i] % 4;
                b[i].y = blocks[n][i] / 4;
            }

        m = 0; rotate = 0;
        window.clear(Color::Green);

        for (int i = 0; i < 4; i++) {
            s.setPosition(b[i].x * 18, b[i].y * 18);
            window.draw(s);
        }

        window.display();
    }

    return 0;
}
